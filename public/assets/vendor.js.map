{"version":3,"sources":["webpack:///vendor.js","webpack:///./src/vendor.ts","webpack:///./~/reflect-metadata/Reflect.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","652","global","Reflect","decorate","decorators","target","targetKey","targetDescriptor","IsUndefined","IsArray","TypeError","IsConstructor","DecorateConstructor","IsObject","ToPropertyKey","DecoratePropertyWithoutDescriptor","DecoratePropertyWithDescriptor","metadata","metadataKey","metadataValue","decorator","OrdinaryDefineOwnMetadata","undefined","defineMetadata","hasMetadata","OrdinaryHasMetadata","hasOwnMetadata","OrdinaryHasOwnMetadata","getMetadata","OrdinaryGetMetadata","getOwnMetadata","OrdinaryGetOwnMetadata","getMetadataKeys","OrdinaryMetadataKeys","getOwnMetadataKeys","OrdinaryOwnMetadataKeys","deleteMetadata","metadataMap","GetOrCreateMetadataMap","size","targetMetadata","Metadata","get","i","length","decorated","propertyKey","descriptor","create","_Map","set","keyMetadata","MetadataKey","O","P","hasOwn","parent","GetPrototypeOf","Boolean","has","MetadataValue","ownKeys","parentKeys","keys","_Set","_i","key","add","_a","getKeys","forEach","_","push","x","Array","isArray","Object","prototype","toString","call","IsSymbol","value","String","proto","getPrototypeOf","functionPrototype","prototypeProto","constructor","IteratorStep","iterator","result","next","done","IteratorClose","f","source","callback","thisArg","entries","forEach_1","CreateMapIterator","values","kind","index","current","throw","error","return","CreateMapPolyfill","cacheSentinel","Map","this","_keys","_values","_cacheKey","_cacheIndex","defineProperty","enumerable","configurable","_find","clear","insert","indexOf","CreateSetPolyfill","Set","_map","CreateWeakMapPolyfill","FillRandomBytes","buffer","Math","random","GenRandomBytes","Uint8Array","crypto","getRandomValues","msCrypto","CreateUUID","data","UUID_SIZE","offset","byte","toLowerCase","CreateUniqueKey","HashMap","GetOrCreateWeakMapTable","rootKey","createDictionary","WeakMap","_key","table","MakeDictionary","obj","__DICTIONARY_MODE__","____DICTIONARY_MODE__","hasOwnProperty","supportsCreate","supportsProto","__","sentinel","instance","__proto__","downLevel","map","Function","_WeakMap","__global","p","window","WorkerGlobalScope","self"],"mappings":"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","file":"vendor.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t// Angular 2\n\t__webpack_require__(21);\n\t__webpack_require__(1);\n\t__webpack_require__(3);\n\t__webpack_require__(22);\n\t__webpack_require__(62);\n\t__webpack_require__(63);\n\t__webpack_require__(652);\n\t// RxJS\n\t__webpack_require__(87);\n\t// Other vendors for example jQuery, Lodash or Bootstrap\n\t// You can import js, ts, css, sass, ... \n\n\n/***/ },\n\n/***/ 652:\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************\r\n\tCopyright (C) Microsoft. All rights reserved.\r\n\tLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n\tthis file except in compliance with the License. You may obtain a copy of the\r\n\tLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\t\r\n\tTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n\tKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n\tWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n\tMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\t\r\n\tSee the Apache Version 2.0 License for specific language governing permissions\r\n\tand limitations under the License.\r\n\t***************************************************************************** */\r\n\tvar Reflect;\r\n\t(function (Reflect) {\r\n\t    \"use strict\";\r\n\t    var hasOwn = Object.prototype.hasOwnProperty;\r\n\t    // feature test for Object.create support\r\n\t    var supportsCreate = typeof Object.create === \"function\";\r\n\t    // feature test for __proto__ support\r\n\t    var supportsProto = (function () {\r\n\t        var sentinel = {};\r\n\t        function __() { }\r\n\t        __.prototype = sentinel;\r\n\t        var instance = new __();\r\n\t        return instance.__proto__ === sentinel;\r\n\t    })();\r\n\t    // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\r\n\t    var createDictionary = supportsCreate ? function () { return MakeDictionary(Object.create(null)); } :\r\n\t        supportsProto ? function () { return MakeDictionary({ __proto__: null }); } :\r\n\t            function () { return MakeDictionary({}); };\r\n\t    var HashMap;\r\n\t    (function (HashMap) {\r\n\t        var downLevel = !supportsCreate && !supportsProto;\r\n\t        HashMap.has = downLevel\r\n\t            ? function (map, key) { return hasOwn.call(map, key); }\r\n\t            : function (map, key) { return key in map; };\r\n\t        HashMap.get = downLevel\r\n\t            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\r\n\t            : function (map, key) { return map[key]; };\r\n\t    })(HashMap || (HashMap = {}));\r\n\t    // Load global or shim versions of Map, Set, and WeakMap\r\n\t    var functionPrototype = Object.getPrototypeOf(Function);\r\n\t    var _Map = typeof Map === \"function\" ? Map : CreateMapPolyfill();\r\n\t    var _Set = typeof Set === \"function\" ? Set : CreateSetPolyfill();\r\n\t    var _WeakMap = typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n\t    // [[Metadata]] internal slot\r\n\t    var Metadata = new _WeakMap();\r\n\t    /**\r\n\t      * Applies a set of decorators to a property of a target object.\r\n\t      * @param decorators An array of decorators.\r\n\t      * @param target The target object.\r\n\t      * @param targetKey (Optional) The property key to decorate.\r\n\t      * @param targetDescriptor (Optional) The property descriptor for the target key\r\n\t      * @remarks Decorators are applied in reverse order.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     Example = Reflect.decorate(decoratorsArray, Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     Object.defineProperty(Example, \"staticMethod\",\r\n\t      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n\t      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     Object.defineProperty(Example.prototype, \"method\",\r\n\t      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n\t      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n\t      *\r\n\t      */\r\n\t    function decorate(decorators, target, targetKey, targetDescriptor) {\r\n\t        if (!IsUndefined(targetDescriptor)) {\r\n\t            if (!IsArray(decorators))\r\n\t                throw new TypeError();\r\n\t            if (!IsObject(target))\r\n\t                throw new TypeError();\r\n\t            if (IsUndefined(targetKey))\r\n\t                throw new TypeError();\r\n\t            if (!IsObject(targetDescriptor))\r\n\t                throw new TypeError();\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);\r\n\t        }\r\n\t        else if (!IsUndefined(targetKey)) {\r\n\t            if (!IsArray(decorators))\r\n\t                throw new TypeError();\r\n\t            if (!IsObject(target))\r\n\t                throw new TypeError();\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);\r\n\t        }\r\n\t        else {\r\n\t            if (!IsArray(decorators))\r\n\t                throw new TypeError();\r\n\t            if (!IsConstructor(target))\r\n\t                throw new TypeError();\r\n\t            return DecorateConstructor(decorators, target);\r\n\t        }\r\n\t    }\r\n\t    Reflect.decorate = decorate;\r\n\t    /**\r\n\t      * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n\t      * @param metadataKey The key for the metadata entry.\r\n\t      * @param metadataValue The value for the metadata entry.\r\n\t      * @returns A decorator function.\r\n\t      * @remarks\r\n\t      * If `metadataKey` is already defined for the target and target key, the\r\n\t      * metadataValue for that key will be overwritten.\r\n\t      * @example\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     @Reflect.metadata(key, value)\r\n\t      *     class Example {\r\n\t      *     }\r\n\t      *\r\n\t      *     // property (on constructor, TypeScript only)\r\n\t      *     class Example {\r\n\t      *         @Reflect.metadata(key, value)\r\n\t      *         static staticProperty;\r\n\t      *     }\r\n\t      *\r\n\t      *     // property (on prototype, TypeScript only)\r\n\t      *     class Example {\r\n\t      *         @Reflect.metadata(key, value)\r\n\t      *         property;\r\n\t      *     }\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     class Example {\r\n\t      *         @Reflect.metadata(key, value)\r\n\t      *         static staticMethod() { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     class Example {\r\n\t      *         @Reflect.metadata(key, value)\r\n\t      *         method() { }\r\n\t      *     }\r\n\t      *\r\n\t      */\r\n\t    function metadata(metadataKey, metadataValue) {\r\n\t        function decorator(target, targetKey) {\r\n\t            if (!IsUndefined(targetKey)) {\r\n\t                if (!IsObject(target))\r\n\t                    throw new TypeError();\r\n\t                targetKey = ToPropertyKey(targetKey);\r\n\t                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n\t            }\r\n\t            else {\r\n\t                if (!IsConstructor(target))\r\n\t                    throw new TypeError();\r\n\t                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);\r\n\t            }\r\n\t        }\r\n\t        return decorator;\r\n\t    }\r\n\t    Reflect.metadata = metadata;\r\n\t    /**\r\n\t      * Define a unique metadata entry on the target.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param metadataValue A value that contains attached metadata.\r\n\t      * @param target The target object on which to define metadata.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\r\n\t      *\r\n\t      *     // decorator factory as metadata-producing annotation.\r\n\t      *     function MyAnnotation(options): Decorator {\r\n\t      *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n\t      *     }\r\n\t      *\r\n\t      */\r\n\t    function defineMetadata(metadataKey, metadataValue, target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n\t    }\r\n\t    Reflect.defineMetadata = defineMetadata;\r\n\t    /**\r\n\t      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function hasMetadata(metadataKey, target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryHasMetadata(metadataKey, target, targetKey);\r\n\t    }\r\n\t    Reflect.hasMetadata = hasMetadata;\r\n\t    /**\r\n\t      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function hasOwnMetadata(metadataKey, target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);\r\n\t    }\r\n\t    Reflect.hasOwnMetadata = hasOwnMetadata;\r\n\t    /**\r\n\t      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function getMetadata(metadataKey, target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryGetMetadata(metadataKey, target, targetKey);\r\n\t    }\r\n\t    Reflect.getMetadata = getMetadata;\r\n\t    /**\r\n\t      * Gets the metadata value for the provided metadata key on the target object.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function getOwnMetadata(metadataKey, target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);\r\n\t    }\r\n\t    Reflect.getOwnMetadata = getOwnMetadata;\r\n\t    /**\r\n\t      * Gets the metadata keys defined on the target object or its prototype chain.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns An array of unique metadata keys.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.getMetadataKeys(Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function getMetadataKeys(target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryMetadataKeys(target, targetKey);\r\n\t    }\r\n\t    Reflect.getMetadataKeys = getMetadataKeys;\r\n\t    /**\r\n\t      * Gets the unique metadata keys defined on the target object.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns An array of unique metadata keys.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.getOwnMetadataKeys(Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function getOwnMetadataKeys(target, targetKey) {\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        return OrdinaryOwnMetadataKeys(target, targetKey);\r\n\t    }\r\n\t    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;\r\n\t    /**\r\n\t      * Deletes the metadata entry from the target object with the provided key.\r\n\t      * @param metadataKey A key used to store and retrieve metadata.\r\n\t      * @param target The target object on which the metadata is defined.\r\n\t      * @param targetKey (Optional) The property key for the target.\r\n\t      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n\t      * @example\r\n\t      *\r\n\t      *     class Example {\r\n\t      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n\t      *         // static staticProperty;\r\n\t      *         // property;\r\n\t      *\r\n\t      *         constructor(p) { }\r\n\t      *         static staticMethod(p) { }\r\n\t      *         method(p) { }\r\n\t      *     }\r\n\t      *\r\n\t      *     // constructor\r\n\t      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n\t      *\r\n\t      *     // property (on constructor)\r\n\t      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n\t      *\r\n\t      *     // property (on prototype)\r\n\t      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n\t      *\r\n\t      *     // method (on constructor)\r\n\t      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n\t      *\r\n\t      *     // method (on prototype)\r\n\t      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n\t      *\r\n\t      */\r\n\t    function deleteMetadata(metadataKey, target, targetKey) {\r\n\t        // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#deletemetadata-metadatakey-p-\r\n\t        if (!IsObject(target))\r\n\t            throw new TypeError();\r\n\t        if (!IsUndefined(targetKey))\r\n\t            targetKey = ToPropertyKey(targetKey);\r\n\t        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n\t        if (IsUndefined(metadataMap))\r\n\t            return false;\r\n\t        if (!metadataMap.delete(metadataKey))\r\n\t            return false;\r\n\t        if (metadataMap.size > 0)\r\n\t            return true;\r\n\t        var targetMetadata = Metadata.get(target);\r\n\t        targetMetadata.delete(targetKey);\r\n\t        if (targetMetadata.size > 0)\r\n\t            return true;\r\n\t        Metadata.delete(target);\r\n\t        return true;\r\n\t    }\r\n\t    Reflect.deleteMetadata = deleteMetadata;\r\n\t    function DecorateConstructor(decorators, target) {\r\n\t        for (var i = decorators.length - 1; i >= 0; --i) {\r\n\t            var decorator = decorators[i];\r\n\t            var decorated = decorator(target);\r\n\t            if (!IsUndefined(decorated)) {\r\n\t                if (!IsConstructor(decorated))\r\n\t                    throw new TypeError();\r\n\t                target = decorated;\r\n\t            }\r\n\t        }\r\n\t        return target;\r\n\t    }\r\n\t    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {\r\n\t        for (var i = decorators.length - 1; i >= 0; --i) {\r\n\t            var decorator = decorators[i];\r\n\t            var decorated = decorator(target, propertyKey, descriptor);\r\n\t            if (!IsUndefined(decorated)) {\r\n\t                if (!IsObject(decorated))\r\n\t                    throw new TypeError();\r\n\t                descriptor = decorated;\r\n\t            }\r\n\t        }\r\n\t        return descriptor;\r\n\t    }\r\n\t    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {\r\n\t        for (var i = decorators.length - 1; i >= 0; --i) {\r\n\t            var decorator = decorators[i];\r\n\t            decorator(target, propertyKey);\r\n\t        }\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#getorcreatemetadatamap--o-p-create-\r\n\t    function GetOrCreateMetadataMap(target, targetKey, create) {\r\n\t        var targetMetadata = Metadata.get(target);\r\n\t        if (!targetMetadata) {\r\n\t            if (!create)\r\n\t                return undefined;\r\n\t            targetMetadata = new _Map();\r\n\t            Metadata.set(target, targetMetadata);\r\n\t        }\r\n\t        var keyMetadata = targetMetadata.get(targetKey);\r\n\t        if (!keyMetadata) {\r\n\t            if (!create)\r\n\t                return undefined;\r\n\t            keyMetadata = new _Map();\r\n\t            targetMetadata.set(targetKey, keyMetadata);\r\n\t        }\r\n\t        return keyMetadata;\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasmetadata--metadatakey-o-p-\r\n\t    function OrdinaryHasMetadata(MetadataKey, O, P) {\r\n\t        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n\t        if (hasOwn)\r\n\t            return true;\r\n\t        var parent = GetPrototypeOf(O);\r\n\t        return parent !== null ? OrdinaryHasMetadata(MetadataKey, parent, P) : false;\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-\r\n\t    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\r\n\t        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n\t        return metadataMap !== undefined && Boolean(metadataMap.has(MetadataKey));\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetmetadata--metadatakey-o-p-\r\n\t    function OrdinaryGetMetadata(MetadataKey, O, P) {\r\n\t        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n\t        if (hasOwn)\r\n\t            return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n\t        var parent = GetPrototypeOf(O);\r\n\t        return parent !== null ? OrdinaryGetMetadata(MetadataKey, parent, P) : undefined;\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetownmetadata--metadatakey-o-p-\r\n\t    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\r\n\t        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n\t        return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-\r\n\t    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\r\n\t        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);\r\n\t        metadataMap.set(MetadataKey, MetadataValue);\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarymetadatakeys--o-p-\r\n\t    function OrdinaryMetadataKeys(O, P) {\r\n\t        var ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n\t        var parent = GetPrototypeOf(O);\r\n\t        if (parent === null)\r\n\t            return ownKeys;\r\n\t        var parentKeys = OrdinaryMetadataKeys(parent, P);\r\n\t        if (parentKeys.length <= 0)\r\n\t            return ownKeys;\r\n\t        if (ownKeys.length <= 0)\r\n\t            return parentKeys;\r\n\t        var keys = new _Set();\r\n\t        for (var _i = 0; _i < ownKeys.length; _i++) {\r\n\t            var key = ownKeys[_i];\r\n\t            keys.add(key);\r\n\t        }\r\n\t        for (var _a = 0; _a < parentKeys.length; _a++) {\r\n\t            var key = parentKeys[_a];\r\n\t            keys.add(key);\r\n\t        }\r\n\t        return getKeys(keys);\r\n\t    }\r\n\t    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryownmetadatakeys--o-p-\r\n\t    function OrdinaryOwnMetadataKeys(target, targetKey) {\r\n\t        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n\t        var keys = [];\r\n\t        if (metadataMap)\r\n\t            forEach(metadataMap, function (_, key) { return keys.push(key); });\r\n\t        return keys;\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type\r\n\t    function IsUndefined(x) {\r\n\t        return x === undefined;\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray\r\n\t    function IsArray(x) {\r\n\t        return Array.isArray ? Array.isArray(x) : x instanceof Array || Object.prototype.toString.call(x) === \"[object Array]\";\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type\r\n\t    function IsObject(x) {\r\n\t        return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor\r\n\t    function IsConstructor(x) {\r\n\t        return typeof x === \"function\";\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type\r\n\t    function IsSymbol(x) {\r\n\t        return typeof x === \"symbol\";\r\n\t    }\r\n\t    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey\r\n\t    function ToPropertyKey(value) {\r\n\t        return IsSymbol(value) ? value : String(value);\r\n\t    }\r\n\t    function GetPrototypeOf(O) {\r\n\t        var proto = Object.getPrototypeOf(O);\r\n\t        if (typeof O !== \"function\" || O === functionPrototype)\r\n\t            return proto;\r\n\t        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\r\n\t        // Try to determine the superclass Exampleonstructor. Compatible implementations\r\n\t        // must either set __proto__ on a subclass Exampleonstructor to the superclass Exampleonstructor,\r\n\t        // or ensure each class has a valid `constructor` property on its prototype that\r\n\t        // points back to the constructor.\r\n\t        // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n\t        // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n\t        if (proto !== functionPrototype)\r\n\t            return proto;\r\n\t        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n\t        var prototype = O.prototype;\r\n\t        var prototypeProto = prototype && Object.getPrototypeOf(prototype);\r\n\t        if (prototypeProto == null || prototypeProto === Object.prototype)\r\n\t            return proto;\r\n\t        // If the constructor was not a function, then we cannot determine the heritage.\r\n\t        var constructor = prototypeProto.constructor;\r\n\t        if (typeof constructor !== \"function\")\r\n\t            return proto;\r\n\t        // If we have some kind of self-reference, then we cannot determine the heritage.\r\n\t        if (constructor === O)\r\n\t            return proto;\r\n\t        // we have a pretty good guess at the heritage.\r\n\t        return constructor;\r\n\t    }\r\n\t    function IteratorStep(iterator) {\r\n\t        var result = iterator.next();\r\n\t        return result.done ? undefined : result;\r\n\t    }\r\n\t    function IteratorClose(iterator) {\r\n\t        var f = iterator[\"return\"];\r\n\t        if (f)\r\n\t            f.call(iterator);\r\n\t    }\r\n\t    function forEach(source, callback, thisArg) {\r\n\t        var entries = source.entries;\r\n\t        if (typeof entries === \"function\") {\r\n\t            var iterator = entries.call(source);\r\n\t            var result;\r\n\t            try {\r\n\t                while (result = IteratorStep(iterator)) {\r\n\t                    var _a = result.value, key = _a[0], value = _a[1];\r\n\t                    callback.call(thisArg, value, key, source);\r\n\t                }\r\n\t            }\r\n\t            finally {\r\n\t                if (result)\r\n\t                    IteratorClose(iterator);\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            var forEach_1 = source.forEach;\r\n\t            if (typeof forEach_1 === \"function\") {\r\n\t                forEach_1.call(source, callback, thisArg);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    function getKeys(source) {\r\n\t        var keys = [];\r\n\t        forEach(source, function (_, key) { keys.push(key); });\r\n\t        return keys;\r\n\t    }\r\n\t    // naive MapIterator shim\r\n\t    function CreateMapIterator(keys, values, kind) {\r\n\t        var index = 0;\r\n\t        return {\r\n\t            next: function () {\r\n\t                if ((keys || values) && index < (keys || values).length) {\r\n\t                    var current = index++;\r\n\t                    switch (kind) {\r\n\t                        case \"key\": return { value: keys[current], done: false };\r\n\t                        case \"value\": return { value: values[current], done: false };\r\n\t                        case \"key+value\": return { value: [keys[current], values[current]], done: false };\r\n\t                    }\r\n\t                }\r\n\t                keys = undefined;\r\n\t                values = undefined;\r\n\t                return { value: undefined, done: true };\r\n\t            },\r\n\t            \"throw\": function (error) {\r\n\t                if (keys || values) {\r\n\t                    keys = undefined;\r\n\t                    values = undefined;\r\n\t                }\r\n\t                throw error;\r\n\t            },\r\n\t            \"return\": function (value) {\r\n\t                if (keys || values) {\r\n\t                    keys = undefined;\r\n\t                    values = undefined;\r\n\t                }\r\n\t                return { value: value, done: true };\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t    // naive Map shim\r\n\t    function CreateMapPolyfill() {\r\n\t        var cacheSentinel = {};\r\n\t        return (function () {\r\n\t            function Map() {\r\n\t                this._keys = [];\r\n\t                this._values = [];\r\n\t                this._cacheKey = cacheSentinel;\r\n\t                this._cacheIndex = -2;\r\n\t            }\r\n\t            Object.defineProperty(Map.prototype, \"size\", {\r\n\t                get: function () { return this._keys.length; },\r\n\t                enumerable: true,\r\n\t                configurable: true\r\n\t            });\r\n\t            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\r\n\t            Map.prototype.get = function (key) {\r\n\t                var index = this._find(key, /*insert*/ false);\r\n\t                return index >= 0 ? this._values[index] : undefined;\r\n\t            };\r\n\t            Map.prototype.set = function (key, value) {\r\n\t                var index = this._find(key, /*insert*/ true);\r\n\t                this._values[index] = value;\r\n\t                return this;\r\n\t            };\r\n\t            Map.prototype.delete = function (key) {\r\n\t                var index = this._find(key, /*insert*/ false);\r\n\t                if (index >= 0) {\r\n\t                    var size = this._keys.length;\r\n\t                    for (var i = index + 1; i < size; i++) {\r\n\t                        this._keys[i - 1] = this._keys[i];\r\n\t                        this._values[i - 1] = this._values[i];\r\n\t                    }\r\n\t                    this._keys.length--;\r\n\t                    this._values.length--;\r\n\t                    this._cacheKey = cacheSentinel;\r\n\t                    this._cacheIndex = -2;\r\n\t                    return true;\r\n\t                }\r\n\t                return false;\r\n\t            };\r\n\t            Map.prototype.clear = function () {\r\n\t                this._keys.length = 0;\r\n\t                this._values.length = 0;\r\n\t                this._cacheKey = cacheSentinel;\r\n\t                this._cacheIndex = -2;\r\n\t            };\r\n\t            Map.prototype.keys = function () { return CreateMapIterator(this._keys, /*values*/ undefined, \"key\"); };\r\n\t            Map.prototype.values = function () { return CreateMapIterator(/*keys*/ undefined, this._values, \"value\"); };\r\n\t            Map.prototype.entries = function () { return CreateMapIterator(this._keys, this._values, \"key+value\"); };\r\n\t            Map.prototype._find = function (key, insert) {\r\n\t                if (this._cacheKey === key)\r\n\t                    return this._cacheIndex;\r\n\t                var index = this._keys.indexOf(key);\r\n\t                if (index < 0 && insert) {\r\n\t                    index = this._keys.length;\r\n\t                    this._keys.push(key);\r\n\t                    this._values.push(undefined);\r\n\t                }\r\n\t                return this._cacheKey = key, this._cacheIndex = index;\r\n\t            };\r\n\t            return Map;\r\n\t        })();\r\n\t    }\r\n\t    // naive Set shim\r\n\t    function CreateSetPolyfill() {\r\n\t        return (function () {\r\n\t            function Set() {\r\n\t                this._map = new _Map();\r\n\t            }\r\n\t            Object.defineProperty(Set.prototype, \"size\", {\r\n\t                get: function () { return this._map.size; },\r\n\t                enumerable: true,\r\n\t                configurable: true\r\n\t            });\r\n\t            Set.prototype.has = function (value) { return this._map.has(value); };\r\n\t            Set.prototype.add = function (value) { return this._map.set(value, value), this; };\r\n\t            Set.prototype.delete = function (value) { return this._map.delete(value); };\r\n\t            Set.prototype.clear = function () { this._map.clear(); };\r\n\t            Set.prototype.keys = function () { return this._map.keys(); };\r\n\t            Set.prototype.values = function () { return this._map.values(); };\r\n\t            Set.prototype.entries = function () { return this._map.entries(); };\r\n\t            return Set;\r\n\t        })();\r\n\t    }\r\n\t    // naive WeakMap shim\r\n\t    function CreateWeakMapPolyfill() {\r\n\t        var UUID_SIZE = 16;\r\n\t        var keys = createDictionary();\r\n\t        var rootKey = CreateUniqueKey();\r\n\t        return (function () {\r\n\t            function WeakMap() {\r\n\t                this._key = CreateUniqueKey();\r\n\t            }\r\n\t            WeakMap.prototype.has = function (target) {\r\n\t                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n\t                return table !== undefined ? HashMap.has(table, this._key) : false;\r\n\t            };\r\n\t            WeakMap.prototype.get = function (target) {\r\n\t                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n\t                return table !== undefined ? HashMap.get(table, this._key) : undefined;\r\n\t            };\r\n\t            WeakMap.prototype.set = function (target, value) {\r\n\t                var table = GetOrCreateWeakMapTable(target, /*create*/ true);\r\n\t                table[this._key] = value;\r\n\t                return this;\r\n\t            };\r\n\t            WeakMap.prototype.delete = function (target) {\r\n\t                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n\t                return table !== undefined ? delete table[this._key] : false;\r\n\t            };\r\n\t            WeakMap.prototype.clear = function () {\r\n\t                // NOTE: not a real clear, just makes the previous data unreachable\r\n\t                this._key = CreateUniqueKey();\r\n\t            };\r\n\t            return WeakMap;\r\n\t        })();\r\n\t        function FillRandomBytes(buffer, size) {\r\n\t            for (var i = 0; i < size; ++i)\r\n\t                buffer[i] = Math.random() * 0xff | 0;\r\n\t            return buffer;\r\n\t        }\r\n\t        function GenRandomBytes(size) {\r\n\t            if (typeof Uint8Array === \"function\") {\r\n\t                if (typeof crypto !== \"undefined\")\r\n\t                    return crypto.getRandomValues(new Uint8Array(size));\r\n\t                if (typeof msCrypto !== \"undefined\")\r\n\t                    return msCrypto.getRandomValues(new Uint8Array(size));\r\n\t                return FillRandomBytes(new Uint8Array(size), size);\r\n\t            }\r\n\t            return FillRandomBytes(new Array(size), size);\r\n\t        }\r\n\t        function CreateUUID() {\r\n\t            var data = GenRandomBytes(UUID_SIZE);\r\n\t            // mark as random - RFC 4122  4.4\r\n\t            data[6] = data[6] & 0x4f | 0x40;\r\n\t            data[8] = data[8] & 0xbf | 0x80;\r\n\t            var result = \"\";\r\n\t            for (var offset = 0; offset < UUID_SIZE; ++offset) {\r\n\t                var byte = data[offset];\r\n\t                if (offset === 4 || offset === 6 || offset === 8)\r\n\t                    result += \"-\";\r\n\t                if (byte < 16)\r\n\t                    result += \"0\";\r\n\t                result += byte.toString(16).toLowerCase();\r\n\t            }\r\n\t            return result;\r\n\t        }\r\n\t        function CreateUniqueKey() {\r\n\t            var key;\r\n\t            do\r\n\t                key = \"@@WeakMap@@\" + CreateUUID();\r\n\t            while (HashMap.has(keys, key));\r\n\t            keys[key] = true;\r\n\t            return key;\r\n\t        }\r\n\t        function GetOrCreateWeakMapTable(target, create) {\r\n\t            if (!hasOwn.call(target, rootKey)) {\r\n\t                if (!create)\r\n\t                    return undefined;\r\n\t                Object.defineProperty(target, rootKey, { value: createDictionary() });\r\n\t            }\r\n\t            return target[rootKey];\r\n\t        }\r\n\t    }\r\n\t    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\r\n\t    function MakeDictionary(obj) {\r\n\t        obj.__DICTIONARY_MODE__ = 1;\r\n\t        delete obj.____DICTIONARY_MODE__;\r\n\t        return obj;\r\n\t    }\r\n\t    // patch global Reflect\r\n\t    (function (__global) {\r\n\t        if (typeof __global.Reflect !== \"undefined\") {\r\n\t            if (__global.Reflect !== Reflect) {\r\n\t                for (var p in Reflect) {\r\n\t                    if (hasOwn.call(Reflect, p)) {\r\n\t                        __global.Reflect[p] = Reflect[p];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            __global.Reflect = Reflect;\r\n\t        }\r\n\t    })(typeof window !== \"undefined\" ? window :\r\n\t        typeof WorkerGlobalScope !== \"undefined\" ? self :\r\n\t            typeof global !== \"undefined\" ? global :\r\n\t                Function(\"return this;\")());\r\n\t})(Reflect || (Reflect = {}));\r\n\t//# sourceMappingURL=Reflect.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** vendor.js\n **/","// Angular 2\nimport '@angular/platform-browser';\nimport '@angular/platform-browser-dynamic';\nimport '@angular/core';\nimport '@angular/common';\nimport '@angular/http';\nimport '@angular/router';\nimport 'reflect-metadata';\n// RxJS\nimport 'rxjs';\n// Other vendors for example jQuery, Lodash or Bootstrap\n// You can import js, ts, css, sass, ...\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular2-template-loader!./src/vendor.ts\n **/","/*! *****************************************************************************\r\nCopyright (C) Microsoft. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\nvar Reflect;\r\n(function (Reflect) {\r\n    \"use strict\";\r\n    var hasOwn = Object.prototype.hasOwnProperty;\r\n    // feature test for Object.create support\r\n    var supportsCreate = typeof Object.create === \"function\";\r\n    // feature test for __proto__ support\r\n    var supportsProto = (function () {\r\n        var sentinel = {};\r\n        function __() { }\r\n        __.prototype = sentinel;\r\n        var instance = new __();\r\n        return instance.__proto__ === sentinel;\r\n    })();\r\n    // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\r\n    var createDictionary = supportsCreate ? function () { return MakeDictionary(Object.create(null)); } :\r\n        supportsProto ? function () { return MakeDictionary({ __proto__: null }); } :\r\n            function () { return MakeDictionary({}); };\r\n    var HashMap;\r\n    (function (HashMap) {\r\n        var downLevel = !supportsCreate && !supportsProto;\r\n        HashMap.has = downLevel\r\n            ? function (map, key) { return hasOwn.call(map, key); }\r\n            : function (map, key) { return key in map; };\r\n        HashMap.get = downLevel\r\n            ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }\r\n            : function (map, key) { return map[key]; };\r\n    })(HashMap || (HashMap = {}));\r\n    // Load global or shim versions of Map, Set, and WeakMap\r\n    var functionPrototype = Object.getPrototypeOf(Function);\r\n    var _Map = typeof Map === \"function\" ? Map : CreateMapPolyfill();\r\n    var _Set = typeof Set === \"function\" ? Set : CreateSetPolyfill();\r\n    var _WeakMap = typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\r\n    // [[Metadata]] internal slot\r\n    var Metadata = new _WeakMap();\r\n    /**\r\n      * Applies a set of decorators to a property of a target object.\r\n      * @param decorators An array of decorators.\r\n      * @param target The target object.\r\n      * @param targetKey (Optional) The property key to decorate.\r\n      * @param targetDescriptor (Optional) The property descriptor for the target key\r\n      * @remarks Decorators are applied in reverse order.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Example = Reflect.decorate(decoratorsArray, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Object.defineProperty(Example, \"staticMethod\",\r\n      *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\r\n      *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\r\n      *\r\n      *     // method (on prototype)\r\n      *     Object.defineProperty(Example.prototype, \"method\",\r\n      *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\r\n      *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\r\n      *\r\n      */\r\n    function decorate(decorators, target, targetKey, targetDescriptor) {\r\n        if (!IsUndefined(targetDescriptor)) {\r\n            if (!IsArray(decorators))\r\n                throw new TypeError();\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            if (IsUndefined(targetKey))\r\n                throw new TypeError();\r\n            if (!IsObject(targetDescriptor))\r\n                throw new TypeError();\r\n            targetKey = ToPropertyKey(targetKey);\r\n            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);\r\n        }\r\n        else if (!IsUndefined(targetKey)) {\r\n            if (!IsArray(decorators))\r\n                throw new TypeError();\r\n            if (!IsObject(target))\r\n                throw new TypeError();\r\n            targetKey = ToPropertyKey(targetKey);\r\n            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);\r\n        }\r\n        else {\r\n            if (!IsArray(decorators))\r\n                throw new TypeError();\r\n            if (!IsConstructor(target))\r\n                throw new TypeError();\r\n            return DecorateConstructor(decorators, target);\r\n        }\r\n    }\r\n    Reflect.decorate = decorate;\r\n    /**\r\n      * A default metadata decorator factory that can be used on a class, class member, or parameter.\r\n      * @param metadataKey The key for the metadata entry.\r\n      * @param metadataValue The value for the metadata entry.\r\n      * @returns A decorator function.\r\n      * @remarks\r\n      * If `metadataKey` is already defined for the target and target key, the\r\n      * metadataValue for that key will be overwritten.\r\n      * @example\r\n      *\r\n      *     // constructor\r\n      *     @Reflect.metadata(key, value)\r\n      *     class Example {\r\n      *     }\r\n      *\r\n      *     // property (on constructor, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticProperty;\r\n      *     }\r\n      *\r\n      *     // property (on prototype, TypeScript only)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         property;\r\n      *     }\r\n      *\r\n      *     // method (on constructor)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         static staticMethod() { }\r\n      *     }\r\n      *\r\n      *     // method (on prototype)\r\n      *     class Example {\r\n      *         @Reflect.metadata(key, value)\r\n      *         method() { }\r\n      *     }\r\n      *\r\n      */\r\n    function metadata(metadataKey, metadataValue) {\r\n        function decorator(target, targetKey) {\r\n            if (!IsUndefined(targetKey)) {\r\n                if (!IsObject(target))\r\n                    throw new TypeError();\r\n                targetKey = ToPropertyKey(targetKey);\r\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n            }\r\n            else {\r\n                if (!IsConstructor(target))\r\n                    throw new TypeError();\r\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, /*targetKey*/ undefined);\r\n            }\r\n        }\r\n        return decorator;\r\n    }\r\n    Reflect.metadata = metadata;\r\n    /**\r\n      * Define a unique metadata entry on the target.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param metadataValue A value that contains attached metadata.\r\n      * @param target The target object on which to define metadata.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\r\n      *\r\n      *     // decorator factory as metadata-producing annotation.\r\n      *     function MyAnnotation(options): Decorator {\r\n      *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\r\n      *     }\r\n      *\r\n      */\r\n    function defineMetadata(metadataKey, metadataValue, target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);\r\n    }\r\n    Reflect.defineMetadata = defineMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryHasMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.hasMetadata = hasMetadata;\r\n    /**\r\n      * Gets a value indicating whether the target object has the provided metadata key defined.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function hasOwnMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.hasOwnMetadata = hasOwnMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryGetMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.getMetadata = getMetadata;\r\n    /**\r\n      * Gets the metadata value for the provided metadata key on the target object.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadata(metadataKey, target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);\r\n    }\r\n    Reflect.getOwnMetadata = getOwnMetadata;\r\n    /**\r\n      * Gets the metadata keys defined on the target object or its prototype chain.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getMetadataKeys(target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryMetadataKeys(target, targetKey);\r\n    }\r\n    Reflect.getMetadataKeys = getMetadataKeys;\r\n    /**\r\n      * Gets the unique metadata keys defined on the target object.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns An array of unique metadata keys.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.getOwnMetadataKeys(Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function getOwnMetadataKeys(target, targetKey) {\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        return OrdinaryOwnMetadataKeys(target, targetKey);\r\n    }\r\n    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;\r\n    /**\r\n      * Deletes the metadata entry from the target object with the provided key.\r\n      * @param metadataKey A key used to store and retrieve metadata.\r\n      * @param target The target object on which the metadata is defined.\r\n      * @param targetKey (Optional) The property key for the target.\r\n      * @returns `true` if the metadata entry was found and deleted; otherwise, false.\r\n      * @example\r\n      *\r\n      *     class Example {\r\n      *         // property declarations are not part of ES6, though they are valid in TypeScript:\r\n      *         // static staticProperty;\r\n      *         // property;\r\n      *\r\n      *         constructor(p) { }\r\n      *         static staticMethod(p) { }\r\n      *         method(p) { }\r\n      *     }\r\n      *\r\n      *     // constructor\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\r\n      *\r\n      *     // property (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\r\n      *\r\n      *     // property (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\r\n      *\r\n      *     // method (on constructor)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\r\n      *\r\n      *     // method (on prototype)\r\n      *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\r\n      *\r\n      */\r\n    function deleteMetadata(metadataKey, target, targetKey) {\r\n        // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#deletemetadata-metadatakey-p-\r\n        if (!IsObject(target))\r\n            throw new TypeError();\r\n        if (!IsUndefined(targetKey))\r\n            targetKey = ToPropertyKey(targetKey);\r\n        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n        if (IsUndefined(metadataMap))\r\n            return false;\r\n        if (!metadataMap.delete(metadataKey))\r\n            return false;\r\n        if (metadataMap.size > 0)\r\n            return true;\r\n        var targetMetadata = Metadata.get(target);\r\n        targetMetadata.delete(targetKey);\r\n        if (targetMetadata.size > 0)\r\n            return true;\r\n        Metadata.delete(target);\r\n        return true;\r\n    }\r\n    Reflect.deleteMetadata = deleteMetadata;\r\n    function DecorateConstructor(decorators, target) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target);\r\n            if (!IsUndefined(decorated)) {\r\n                if (!IsConstructor(decorated))\r\n                    throw new TypeError();\r\n                target = decorated;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            var decorated = decorator(target, propertyKey, descriptor);\r\n            if (!IsUndefined(decorated)) {\r\n                if (!IsObject(decorated))\r\n                    throw new TypeError();\r\n                descriptor = decorated;\r\n            }\r\n        }\r\n        return descriptor;\r\n    }\r\n    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {\r\n        for (var i = decorators.length - 1; i >= 0; --i) {\r\n            var decorator = decorators[i];\r\n            decorator(target, propertyKey);\r\n        }\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#getorcreatemetadatamap--o-p-create-\r\n    function GetOrCreateMetadataMap(target, targetKey, create) {\r\n        var targetMetadata = Metadata.get(target);\r\n        if (!targetMetadata) {\r\n            if (!create)\r\n                return undefined;\r\n            targetMetadata = new _Map();\r\n            Metadata.set(target, targetMetadata);\r\n        }\r\n        var keyMetadata = targetMetadata.get(targetKey);\r\n        if (!keyMetadata) {\r\n            if (!create)\r\n                return undefined;\r\n            keyMetadata = new _Map();\r\n            targetMetadata.set(targetKey, keyMetadata);\r\n        }\r\n        return keyMetadata;\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasmetadata--metadatakey-o-p-\r\n    function OrdinaryHasMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn)\r\n            return true;\r\n        var parent = GetPrototypeOf(O);\r\n        return parent !== null ? OrdinaryHasMetadata(MetadataKey, parent, P) : false;\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-\r\n    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n        return metadataMap !== undefined && Boolean(metadataMap.has(MetadataKey));\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetmetadata--metadatakey-o-p-\r\n    function OrdinaryGetMetadata(MetadataKey, O, P) {\r\n        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\r\n        if (hasOwn)\r\n            return OrdinaryGetOwnMetadata(MetadataKey, O, P);\r\n        var parent = GetPrototypeOf(O);\r\n        return parent !== null ? OrdinaryGetMetadata(MetadataKey, parent, P) : undefined;\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarygetownmetadata--metadatakey-o-p-\r\n    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ false);\r\n        return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-\r\n    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\r\n        var metadataMap = GetOrCreateMetadataMap(O, P, /*create*/ true);\r\n        metadataMap.set(MetadataKey, MetadataValue);\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinarymetadatakeys--o-p-\r\n    function OrdinaryMetadataKeys(O, P) {\r\n        var ownKeys = OrdinaryOwnMetadataKeys(O, P);\r\n        var parent = GetPrototypeOf(O);\r\n        if (parent === null)\r\n            return ownKeys;\r\n        var parentKeys = OrdinaryMetadataKeys(parent, P);\r\n        if (parentKeys.length <= 0)\r\n            return ownKeys;\r\n        if (ownKeys.length <= 0)\r\n            return parentKeys;\r\n        var keys = new _Set();\r\n        for (var _i = 0; _i < ownKeys.length; _i++) {\r\n            var key = ownKeys[_i];\r\n            keys.add(key);\r\n        }\r\n        for (var _a = 0; _a < parentKeys.length; _a++) {\r\n            var key = parentKeys[_a];\r\n            keys.add(key);\r\n        }\r\n        return getKeys(keys);\r\n    }\r\n    // https://github.com/rbuckton/ReflectDecorators/blob/master/spec/metadata.md#ordinaryownmetadatakeys--o-p-\r\n    function OrdinaryOwnMetadataKeys(target, targetKey) {\r\n        var metadataMap = GetOrCreateMetadataMap(target, targetKey, /*create*/ false);\r\n        var keys = [];\r\n        if (metadataMap)\r\n            forEach(metadataMap, function (_, key) { return keys.push(key); });\r\n        return keys;\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type\r\n    function IsUndefined(x) {\r\n        return x === undefined;\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray\r\n    function IsArray(x) {\r\n        return Array.isArray ? Array.isArray(x) : x instanceof Array || Object.prototype.toString.call(x) === \"[object Array]\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type\r\n    function IsObject(x) {\r\n        return typeof x === \"object\" ? x !== null : typeof x === \"function\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor\r\n    function IsConstructor(x) {\r\n        return typeof x === \"function\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type\r\n    function IsSymbol(x) {\r\n        return typeof x === \"symbol\";\r\n    }\r\n    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey\r\n    function ToPropertyKey(value) {\r\n        return IsSymbol(value) ? value : String(value);\r\n    }\r\n    function GetPrototypeOf(O) {\r\n        var proto = Object.getPrototypeOf(O);\r\n        if (typeof O !== \"function\" || O === functionPrototype)\r\n            return proto;\r\n        // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\r\n        // Try to determine the superclass Exampleonstructor. Compatible implementations\r\n        // must either set __proto__ on a subclass Exampleonstructor to the superclass Exampleonstructor,\r\n        // or ensure each class has a valid `constructor` property on its prototype that\r\n        // points back to the constructor.\r\n        // If this is not the same as Function.[[Prototype]], then this is definately inherited.\r\n        // This is the case when in ES6 or when using __proto__ in a compatible browser.\r\n        if (proto !== functionPrototype)\r\n            return proto;\r\n        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\r\n        var prototype = O.prototype;\r\n        var prototypeProto = prototype && Object.getPrototypeOf(prototype);\r\n        if (prototypeProto == null || prototypeProto === Object.prototype)\r\n            return proto;\r\n        // If the constructor was not a function, then we cannot determine the heritage.\r\n        var constructor = prototypeProto.constructor;\r\n        if (typeof constructor !== \"function\")\r\n            return proto;\r\n        // If we have some kind of self-reference, then we cannot determine the heritage.\r\n        if (constructor === O)\r\n            return proto;\r\n        // we have a pretty good guess at the heritage.\r\n        return constructor;\r\n    }\r\n    function IteratorStep(iterator) {\r\n        var result = iterator.next();\r\n        return result.done ? undefined : result;\r\n    }\r\n    function IteratorClose(iterator) {\r\n        var f = iterator[\"return\"];\r\n        if (f)\r\n            f.call(iterator);\r\n    }\r\n    function forEach(source, callback, thisArg) {\r\n        var entries = source.entries;\r\n        if (typeof entries === \"function\") {\r\n            var iterator = entries.call(source);\r\n            var result;\r\n            try {\r\n                while (result = IteratorStep(iterator)) {\r\n                    var _a = result.value, key = _a[0], value = _a[1];\r\n                    callback.call(thisArg, value, key, source);\r\n                }\r\n            }\r\n            finally {\r\n                if (result)\r\n                    IteratorClose(iterator);\r\n            }\r\n        }\r\n        else {\r\n            var forEach_1 = source.forEach;\r\n            if (typeof forEach_1 === \"function\") {\r\n                forEach_1.call(source, callback, thisArg);\r\n            }\r\n        }\r\n    }\r\n    function getKeys(source) {\r\n        var keys = [];\r\n        forEach(source, function (_, key) { keys.push(key); });\r\n        return keys;\r\n    }\r\n    // naive MapIterator shim\r\n    function CreateMapIterator(keys, values, kind) {\r\n        var index = 0;\r\n        return {\r\n            next: function () {\r\n                if ((keys || values) && index < (keys || values).length) {\r\n                    var current = index++;\r\n                    switch (kind) {\r\n                        case \"key\": return { value: keys[current], done: false };\r\n                        case \"value\": return { value: values[current], done: false };\r\n                        case \"key+value\": return { value: [keys[current], values[current]], done: false };\r\n                    }\r\n                }\r\n                keys = undefined;\r\n                values = undefined;\r\n                return { value: undefined, done: true };\r\n            },\r\n            \"throw\": function (error) {\r\n                if (keys || values) {\r\n                    keys = undefined;\r\n                    values = undefined;\r\n                }\r\n                throw error;\r\n            },\r\n            \"return\": function (value) {\r\n                if (keys || values) {\r\n                    keys = undefined;\r\n                    values = undefined;\r\n                }\r\n                return { value: value, done: true };\r\n            }\r\n        };\r\n    }\r\n    // naive Map shim\r\n    function CreateMapPolyfill() {\r\n        var cacheSentinel = {};\r\n        return (function () {\r\n            function Map() {\r\n                this._keys = [];\r\n                this._values = [];\r\n                this._cacheKey = cacheSentinel;\r\n                this._cacheIndex = -2;\r\n            }\r\n            Object.defineProperty(Map.prototype, \"size\", {\r\n                get: function () { return this._keys.length; },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };\r\n            Map.prototype.get = function (key) {\r\n                var index = this._find(key, /*insert*/ false);\r\n                return index >= 0 ? this._values[index] : undefined;\r\n            };\r\n            Map.prototype.set = function (key, value) {\r\n                var index = this._find(key, /*insert*/ true);\r\n                this._values[index] = value;\r\n                return this;\r\n            };\r\n            Map.prototype.delete = function (key) {\r\n                var index = this._find(key, /*insert*/ false);\r\n                if (index >= 0) {\r\n                    var size = this._keys.length;\r\n                    for (var i = index + 1; i < size; i++) {\r\n                        this._keys[i - 1] = this._keys[i];\r\n                        this._values[i - 1] = this._values[i];\r\n                    }\r\n                    this._keys.length--;\r\n                    this._values.length--;\r\n                    this._cacheKey = cacheSentinel;\r\n                    this._cacheIndex = -2;\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n            Map.prototype.clear = function () {\r\n                this._keys.length = 0;\r\n                this._values.length = 0;\r\n                this._cacheKey = cacheSentinel;\r\n                this._cacheIndex = -2;\r\n            };\r\n            Map.prototype.keys = function () { return CreateMapIterator(this._keys, /*values*/ undefined, \"key\"); };\r\n            Map.prototype.values = function () { return CreateMapIterator(/*keys*/ undefined, this._values, \"value\"); };\r\n            Map.prototype.entries = function () { return CreateMapIterator(this._keys, this._values, \"key+value\"); };\r\n            Map.prototype._find = function (key, insert) {\r\n                if (this._cacheKey === key)\r\n                    return this._cacheIndex;\r\n                var index = this._keys.indexOf(key);\r\n                if (index < 0 && insert) {\r\n                    index = this._keys.length;\r\n                    this._keys.push(key);\r\n                    this._values.push(undefined);\r\n                }\r\n                return this._cacheKey = key, this._cacheIndex = index;\r\n            };\r\n            return Map;\r\n        })();\r\n    }\r\n    // naive Set shim\r\n    function CreateSetPolyfill() {\r\n        return (function () {\r\n            function Set() {\r\n                this._map = new _Map();\r\n            }\r\n            Object.defineProperty(Set.prototype, \"size\", {\r\n                get: function () { return this._map.size; },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n            Set.prototype.has = function (value) { return this._map.has(value); };\r\n            Set.prototype.add = function (value) { return this._map.set(value, value), this; };\r\n            Set.prototype.delete = function (value) { return this._map.delete(value); };\r\n            Set.prototype.clear = function () { this._map.clear(); };\r\n            Set.prototype.keys = function () { return this._map.keys(); };\r\n            Set.prototype.values = function () { return this._map.values(); };\r\n            Set.prototype.entries = function () { return this._map.entries(); };\r\n            return Set;\r\n        })();\r\n    }\r\n    // naive WeakMap shim\r\n    function CreateWeakMapPolyfill() {\r\n        var UUID_SIZE = 16;\r\n        var keys = createDictionary();\r\n        var rootKey = CreateUniqueKey();\r\n        return (function () {\r\n            function WeakMap() {\r\n                this._key = CreateUniqueKey();\r\n            }\r\n            WeakMap.prototype.has = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.has(table, this._key) : false;\r\n            };\r\n            WeakMap.prototype.get = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? HashMap.get(table, this._key) : undefined;\r\n            };\r\n            WeakMap.prototype.set = function (target, value) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ true);\r\n                table[this._key] = value;\r\n                return this;\r\n            };\r\n            WeakMap.prototype.delete = function (target) {\r\n                var table = GetOrCreateWeakMapTable(target, /*create*/ false);\r\n                return table !== undefined ? delete table[this._key] : false;\r\n            };\r\n            WeakMap.prototype.clear = function () {\r\n                // NOTE: not a real clear, just makes the previous data unreachable\r\n                this._key = CreateUniqueKey();\r\n            };\r\n            return WeakMap;\r\n        })();\r\n        function FillRandomBytes(buffer, size) {\r\n            for (var i = 0; i < size; ++i)\r\n                buffer[i] = Math.random() * 0xff | 0;\r\n            return buffer;\r\n        }\r\n        function GenRandomBytes(size) {\r\n            if (typeof Uint8Array === \"function\") {\r\n                if (typeof crypto !== \"undefined\")\r\n                    return crypto.getRandomValues(new Uint8Array(size));\r\n                if (typeof msCrypto !== \"undefined\")\r\n                    return msCrypto.getRandomValues(new Uint8Array(size));\r\n                return FillRandomBytes(new Uint8Array(size), size);\r\n            }\r\n            return FillRandomBytes(new Array(size), size);\r\n        }\r\n        function CreateUUID() {\r\n            var data = GenRandomBytes(UUID_SIZE);\r\n            // mark as random - RFC 4122  4.4\r\n            data[6] = data[6] & 0x4f | 0x40;\r\n            data[8] = data[8] & 0xbf | 0x80;\r\n            var result = \"\";\r\n            for (var offset = 0; offset < UUID_SIZE; ++offset) {\r\n                var byte = data[offset];\r\n                if (offset === 4 || offset === 6 || offset === 8)\r\n                    result += \"-\";\r\n                if (byte < 16)\r\n                    result += \"0\";\r\n                result += byte.toString(16).toLowerCase();\r\n            }\r\n            return result;\r\n        }\r\n        function CreateUniqueKey() {\r\n            var key;\r\n            do\r\n                key = \"@@WeakMap@@\" + CreateUUID();\r\n            while (HashMap.has(keys, key));\r\n            keys[key] = true;\r\n            return key;\r\n        }\r\n        function GetOrCreateWeakMapTable(target, create) {\r\n            if (!hasOwn.call(target, rootKey)) {\r\n                if (!create)\r\n                    return undefined;\r\n                Object.defineProperty(target, rootKey, { value: createDictionary() });\r\n            }\r\n            return target[rootKey];\r\n        }\r\n    }\r\n    // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\r\n    function MakeDictionary(obj) {\r\n        obj.__DICTIONARY_MODE__ = 1;\r\n        delete obj.____DICTIONARY_MODE__;\r\n        return obj;\r\n    }\r\n    // patch global Reflect\r\n    (function (__global) {\r\n        if (typeof __global.Reflect !== \"undefined\") {\r\n            if (__global.Reflect !== Reflect) {\r\n                for (var p in Reflect) {\r\n                    if (hasOwn.call(Reflect, p)) {\r\n                        __global.Reflect[p] = Reflect[p];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            __global.Reflect = Reflect;\r\n        }\r\n    })(typeof window !== \"undefined\" ? window :\r\n        typeof WorkerGlobalScope !== \"undefined\" ? self :\r\n            typeof global !== \"undefined\" ? global :\r\n                Function(\"return this;\")());\r\n})(Reflect || (Reflect = {}));\r\n//# sourceMappingURL=Reflect.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/reflect-metadata/Reflect.js\n ** module id = 652\n ** module chunks = 2\n **/"],"sourceRoot":""}